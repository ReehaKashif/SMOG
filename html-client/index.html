// Initialize the map
const map = L.map('forecastMap').setView([31.5, 73.0], 7);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 18,
  attribution: 'Map data Â© OpenStreetMap contributors'
}).addTo(map);

// Load GeoJSON data for district boundaries
fetch('districts_geojson.geojson')
  .then(response => response.json())
  .then(data => {
    // Store the GeoJSON layer for later access
    const geoJsonLayer = L.geoJSON(data, {
      style: function (feature) {
        return {
          color: 'blue',
          weight: 2,
          opacity: 0.8,
          fillOpacity: 0.4
        };
      },
      onEachFeature: function (feature, layer) {
        layer.on({
          mouseover: highlightFeature,
          mouseout: resetHighlight
        });
      }
    }).addTo(map);

    // Update district data based on date and source ranking
    async function updateDistrictData(date, ranking = 'top') {
      const formattedDate = new Date(date).toLocaleDateString('en-US');

      data.features.forEach(async (feature) => {
        const district = feature.properties.district; // Corrected property name

        if (!district) {
          console.warn('Feature does not have a district name:', feature);
          return; // Skip processing if the district name is missing
        }

        try {
          console.log(`Fetching data for district: ${district}`); // Debugging log
          const response = await fetch(`https://smog-server.onrender.com/api/october_sources?input_date=${encodeURIComponent(formattedDate)}&input_district=${encodeURIComponent(district)}`);
          
          if (!response.ok) {
            console.error(`Network response for ${district} was not ok`);
            return;
          }

          const data = await response.json();
          console.log(`Data received for ${district}:`, data); // Debugging log

          // Check if the necessary fields are present
          if (!data || !data.Sum_of_Sources) {
            console.warn(`Data for ${district} is incomplete or missing:`, data);
            return; // Skip this district if data is incomplete
          }

          // Determine the color and source value based on ranking
          const sources = [
            { name: 'Vehicles', value: data.Vehicle || 0, percent: data['Vehicle%'] || 0, color: "#ffa500" },
            { name: 'Industry', value: data.Industry || 0, percent: data['Industry%'] || 0, color: "#f2af2a" },
            { name: 'Agriculture', value: data.Agriculture || 0, percent: data['Agriculture%'] || 0, color: "#36454f" },
            { name: 'Construction', value: data.Construction || 0, percent: data['Construction%'] || 0, color: "#ff2600" },
            { name: 'ResidentialHeat', value: data.Residential || 0, percent: data['Residential%'] || 0, color: "#ADD8E6" },
            { name: 'Misc', value: data.Misc || 0, percent: data['Misc%'] || 0, color: "#7a288a" }
          ];

          sources.sort((a, b) => b.percent - a.percent);

          let selectedSource;
          if (ranking === 'top') selectedSource = sources[0];
          else if (ranking === 'second') selectedSource = sources[1];
          else if (ranking === 'third') selectedSource = sources[2];

          if (!selectedSource) {
            console.warn(`No source data found for ${district}`);
            return;
          }

          // Set district color
          feature.properties.color = selectedSource.color;

          // Create content for the popup
          const popupContent = `
            <div>
              <strong>District:</strong> ${district}<br/>
              <strong>AQI:</strong> ${data.Sum_of_Sources ? data.Sum_of_Sources.toFixed(0) : 'N/A'}<br/>
              <strong>Temp:</strong> ${data.Temperature || '-'}<br/>
              <strong>Windspeed:</strong> ${data.Windspeed || '-'}<br/>
              <table class="table table-bordered mt-2">
                <thead>
                  <tr>
                    <th>Source</th>
                    <th>Value</th>
                    <th>%</th>
                  </tr>
                </thead>
                <tbody>
                  ${sources.map(source => `<tr><td>${source.name}</td><td>${source.value.toFixed(0)}</td><td>${source.percent.toFixed(0)}%</td></tr>`).join('')}
                </tbody>
              </table>
            </div>
          `;

          // Bind the popup to the district
          L.geoJSON(feature, {
            style: { color: selectedSource.color, weight: 2, opacity: 0.8, fillOpacity: 0.4 }
          }).bindPopup(popupContent).addTo(map);
        } catch (error) {
          console.error(`Failed to fetch data for ${district}:`, error);
        }
      });
    }

    // Event listener for date and source ranking change
    document.getElementById('date-picker').addEventListener('change', function() {
      const selectedDate = this.value;
      const selectedRanking = document.getElementById('source-ranking').value;
      if (selectedDate) {
        // Remove previous layers and update with new data
        map.eachLayer((layer) => {
          if (layer !== geoJsonLayer) {
            map.removeLayer(layer);
          }
        });
        updateDistrictData(selectedDate, selectedRanking);
      }
    });

    document.getElementById('source-ranking').addEventListener('change', function() {
      const selectedDate = document.getElementById('date-picker').value;
      const selectedRanking = this.value;
      if (selectedDate) {
        // Remove previous layers and update with new data
        map.eachLayer((layer) => {
          if (layer !== geoJsonLayer) {
            map.removeLayer(layer);
          }
        });
        updateDistrictData(selectedDate, selectedRanking);
      }
    });

    function highlightFeature(e) {
      const layer = e.target;
      layer.setStyle({
        weight: 3,
        color: '#666',
        fillOpacity: 0.7
      });
    }

    function resetHighlight(e) {
      const layer = e.target;
      geoJsonLayer.resetStyle(layer);
    }
  })
  .catch(error => console.error('Error loading GeoJSON data:', error));
